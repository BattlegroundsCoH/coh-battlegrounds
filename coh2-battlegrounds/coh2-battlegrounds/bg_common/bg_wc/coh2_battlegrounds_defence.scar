------------------------------------------------------------------------------------
-- Point and Time check
------------------------------------------------------------------------------------

function BattlegroundsDefence_InitGamemode()

	-- Init settings
	DefenceSettingsData = {

		-- Grab points
		MaxPoints = Setup_GetWinConditionOption(),
		DefenderPoints = Setup_GetWinConditionOption(),

		-- Create counter Id
		Counter = 333,

		-- Create teritory group
		Sectors = {}

	}

	-- Define teams
	__BGDefenceTeams = {
		Team_GetPlayers(bg_settings.team_first), 
		Team_GetPlayers(bg_settings.team_second)
	}

	-- Log amount of players on each team
	bgdebug(#__BGDefenceTeams[1] .. " and " ..#__BGDefenceTeams[2])

	-- Init sectors
	BattlegroundsDefence_InitSectors()

	-- Set points
	WinWarning_SetMaxTickers(DefenceSettingsData.MaxPoints, DefenceSettingsData.DefenderPoints)
	WinWarning_SetTickers(DefenceSettingsData.MaxPoints - DefenceSettingsData.DefenderPoints, DefenceSettingsData.DefenderPoints)

	-- Start timer
	Timer_Start(DefenceSettingsData.Counter, bg_settings.gameoptions.Time * 60)

	-- Add interval to update points
	Rule_AddInterval(BattlegroundsDefence_UpdatePoints, 3);
	Rule_AddInterval(BattlegroundsDefence_CheckTime, 5);

end

function BattlegroundsDefence_InitSectors()

	-- Get first player of the defending team
	local defender = __BGDefenceTeams[2][1]

	-- Loop over stategic points
	for i=0, World_GetNumEntities()-1 do
		local entity = World_GetEntity(i)

		-- Collect point if strategic point
		if Entity_IsStrategicPoint(entity) and BP_GetName(Entity_GetBlueprint(entity)) ~= "starting_territory_team" then

			-- Insert into list of sectors
			table.insert(DefenceSettingsData.Sectors, entity)
			
			-- Capture by defender
			Entity_InstantCaptureStrategicPoint(entity, defender)

		end
	end

end

function BattlegroundsDefence_UpdatePoints()

	-- Get first player of the defending and attacking teams
	local attacker = __BGDefenceTeams[1][1]
	local defender = __BGDefenceTeams[2][1]

	-- Create counts
	local counts = { 0, 0 }

	-- Collect status
	for _, v in pairs(DefenceSettingsData.Sectors) do
		if Entity_IsStrategicPointCapturedBy(v, defender) then
			counts[2] = counts[2] + 1
		elseif Entity_IsStrategicPointCapturedBy(v, attacker) then
			counts[1] = counts[1] + 1
		end
	end

	-- Calculate penalty and cap penalty
	local inplay = counts[1] + counts[2]
	local defenderPenalty = math.floor((counts[1] / counts[2] * inplay) / 3)
	if defenderPenalty < 0 then
		defenderPenalty = 0
	elseif defenderPenalty > 3 then
		defenderPenalty = 3
	end

	-- Log
	bgdebug("points: " .. counts[1] .. " vs " ..counts[2] .. " penality = " ..defenderPenalty)

	-- Update points
	DefenceSettingsData.DefenderPoints = DefenceSettingsData.DefenderPoints - defenderPenalty
	if DefenceSettingsData.DefenderPoints <= 0 then

		-- Set to 0
		DefenceSettingsData.DefenderPoints = 0

		-- Set winner to attacking team
		World_SetTeamWin(Player_GetTeam(__BGDefenceTeams[1][1]))

	end

	-- Grab points
	local team1Tickers = DefenceSettingsData.MaxPoints - DefenceSettingsData.DefenderPoints
	local team2Tickers = DefenceSettingsData.DefenderPoints

	-- Log
	bgdebug("tickers: " .. team1Tickers .. " vs " ..team2Tickers)

	-- Update visually
	WinWarning_SetTickers(team1Tickers, team2Tickers)
	WinWarning_SetCritical(false, 100 * team2Tickers / DefenceSettingsData.MaxPoints <= 20)

	-- Sync
	Misc_SyncCheckVariable("Team 1 Tickers", team1Tickers)
	Misc_SyncCheckVariable("Team 2 Tickers", team2Tickers)

end

function BattlegroundsDefence_CheckTime()

	-- Check timer
	if Timer_GetRemaining(DefenceSettingsData.Counter) <= 0 then

		-- Remove rules
		Rule_Remove(BattlegroundsDefence_UpdatePoints)
		Rule_RemoveMe();

		-- Pick winner
		if DefenceSettingsData.DefenderPoints < DefenceSettingsData.MaxPoints / 2 then -- defenders have less than half, so attackers win
			World_SetTeamWin(Player_GetTeam(__BGDefenceTeams[1][1]))
		else -- defenders have more than half, so defenders win
			World_SetTeamWin(Player_GetTeam(__BGDefenceTeams[2][1]))
		end

	end

end

------------------------------------------------------------------------------------
-- Spawn Defences
------------------------------------------------------------------------------------

function BattlegroundsDefence_InitDefence()

	-- Grab defence data and spawn it in
	local defence_entities = bg_plandata.entities;
	for i=1, #defence_entities do

		-- Grab owner and ebp
		local owner = BattlegroundsDefence_SolveOwner(defence_entities[i].team, defence_entities[i].player)
		local ebp = BP_GetEntityBlueprint(defence_entities[i].ebp)

		-- Grab positions
		local pos = Util_GetPosition(pos.x, pos.y, pos.z)
		local lookat = Util_GetPosition(lookat.x, lookat.y, lookat.z)

		if defence_entities[i].mode == "place" then
			Entity_Spawn(BattlegroundsDefence_CreateEntity(ebp, owner, pos, pos))
		elseif defence_entities[i].mode == "lookat" then
			Entity_Spawn(BattlegroundsDefence_CreateEntity(ebp, owner, pos, pos))
		elseif defence_entities[i].mode == "line" then
			BattlegroundsDefence_SpawnLine(owner, ebp, pos, lookat, defence_entities[i].width)
		end
	end

	-- Grab defence unit data and call them in
	local defence_squads = bg_plandata.squads;
	for i=1, #defence_squads do
		local owner = BattlegroundsDefence_SolveOwner(defence_squads[i].team, defence_squads[i].player)
		local squad = BG_DeploySquad(owner, defence_squads[i].sid, true)
		if squad then
			BattlegroundsDefence_SetupSquad(squad, defence_squads[i].pos, defence_squads[i].target)
		end
	end

end

function BattlegroundsDefence_SolveOwner(team, indexOnTeam)
	return __BGDefenceTeams[team][indexOnTeam]
end

function BattlegroundsDefence_CreateEntity(bp, owner, pos, lookat)
	if owner == nil then
		return Entity_CreateENV(bp, pos, lookat)
	else
		return Entity_Create(bp, owner, pos, lookat)
	end
end

function BattlegroundsDefence_SpawnLine(owner, bp, startpos, endpos, width)

	-- Grab positions
	startpos = Util_GetPosition(startpos.x, startpos.y, startpos.z)
	endpos = Util_GetPosition(endpos.x, endpos.y, endpos.z)

	-- Grab distance
	local dist = Util_GetDistance(startpos, endpos)

	-- Grab amount to spawn
	local count = math.floor(dist / width)

	-- Loop over
	for i=1, count do

		-- Grab pos
		local pos = Util_GetPositionFromAtoB(startpos, endpos, i / count)
		local lookat = Util_GetPositionFromAtoB(startpos, endpos, i / count + 0.1)
		lookat = Util_GetPosition(0,0,0) -- TODO: Properly get pos

		-- Create entity
		local entity = BattlegroundsDefence_CreateEntity(bp, owner, pos, lookat)

		-- Grab nearest spawnable position
		local bestpos = World_GetSpawnablePosition(pos, entity)

		-- Update position (Maybe check if too far away then bail)
		Entity_SetPosition(entity, bestpos)

	end

end

function BattlegroundsDefence_SetupSquad(squad, pos, lookat)

	-- Grab positions
	pos = Util_GetPosition(pos.x, pos.y, pos.z)
	lookat = Util_GetPosition(lookat.x, lookat.y, lookat.z) and lookat

	-- Try garrison
	local sg_temp = SGroup_FromSquad(squad)
	local garrisonId = nil

	-- Try spawn in garrison if infantry
	if Squad_IsInfantrySquad(squad) then
		garrisonId = Util_GarrisonNearbyBuilding(sg_temp, pos, 7.5, false)
	end

	-- If not garrisoned, warp to pos and look at target (if any)
	if garrisonId == nil then
		Squad_WarpToPos(squad, pos)
		if lookat ~= nil then
			Squad_FacePosition(squad, lookat)
			if Squad_GetSyncWeapon(squad) ~= nil then
				Cmd_InstantSetupTeamWeapon(sg_temp)
			end
		end
	end

end

------------------------------------------------------------------------------------
-- Objectives Check
------------------------------------------------------------------------------------

-- Battlegrounds Objective Types
BG_OT_ATTACK = 1 -- Attack position (capture)
BG_OT_DEFEND = 2 -- Defend position (hold for 3 minutes)
BG_OT_SUPPORT = 3 --  Support position (provide support for another player for 3 minutes)

function BattlegroundsDefence_InitObjectives()
	
	-- Bail if no objectives are defined
	if #bg_plandata.objectives == 0 then
		return
	end

	-- Create main objective
	OBJ_DefenceMain = {
		SetupUI = function() end,
		OnStart = function() end,
		OnComplete = function()	end,
		OnFail = function() end,
		IsComplete = function() return false end,
		Title = BG_LocString(110),
		Type = OT_Primary,
	}

	-- Register main objective
	Objective_Register(OBJ_DefenceMain)

	-- Create objective order
	OBJ_DefenceAllAssault = {}

	-- Loop over all objectives and queue
	for _, v in pairs(bg_plandata.objectives) do
		
		-- Grab owner
		local owner = BattlegroundsDefence_SolveOwner(v.team, v.player)
		local ownerid = Player_GetID(owner)

		-- Init container
		if OBJ_DefenceAllAssault[ownerid] == nil then
			OBJ_DefenceAllAssault[ownerid] = {
				objectives = {},
				current = 1
			}
		end

		-- Insert objective
		OBJ_DefenceAllAssault[ownerid].objectives[v.order + 1] = BattlegroundsDefence_CreateObjective(v.type, v.pos)

		-- Register objective
		Objective_Register(OBJ_DefenceAllAssault[ownerid].objectives[v.order + 1])

	end

	-- Begin objectives delayed
	Rule_AddOneShot(BattlegroundsDefence_DelayedStartObjectives, 30);

end

function BattlegroundsDefence_DelayedStartObjectives()

	-- Loop over all objectives and start them
	for k,v in pairs(OBJ_DefenceAllAssault) do
		BattlegroundsDefence_StartObjective(k, v.objectives[1])
	end

	-- Add check every 10s
	Rule_AddInterval(BattlegroundsDefence_CheckObjectives, 10)

end

function BattlegroundsDefence_CreateObjective(objectiveType, objectivePosition)
	local obj = {
		SetupUI = function() end,
		OnStart = function() end,
		OnComplete = function()	end,
		OnFail = function() end,
		IsComplete = function() return false end,
		Type = OT_Primary,
		Parent = OBJ_DefenceMain,
	}
	local pos = World_GetNearestInteractablePoint(World_Pos(objectivePosition.x, objectivePosition.y, objectivePosition.z))
	if objectiveType == BG_OT_ATTACK then

		-- Loop over points in range
		local targetPoints = {}
		for _, v in pairs(DefenceSettingsData.Sectors)  do
			if Util_GetDistance(pos, Entity_GetPosition(v)) < 35 then
				table.insert(targetPoints, v)
			end
		end

		-- Capture points if any; otherwise it's a clear objective
		if #targetPoints > 0 then
			obj.targets = targetPoints
			obj.__oncheck = BattlegroundsDefence_CheckCapture
			obj.__oncomplete = function (self)
				DefenceSettingsData.DefenderPoints = DefenceSettingsData.DefenderPoints - 10 * #self.targets
			end
			obj.OnStart = function ()
				Objective_SetCounter(obj, 0, #obj.targets)
				obj.targetsui = {}
				for k, v in ipairs(obj.targets) do
					obj.targetsui[k] = Objective_AddUIElements(obj, Entity_GetPosition(v), true, BG_LocString(114), true)
				end
			end
		else -- Else, clear the area
			obj.attackpos = pos
			obj.__oncheck = BattlegroundsDefence_CheckCleared
			obj.__oncomplete = function (self)
				DefenceSettingsData.DefenderPoints = DefenceSettingsData.DefenderPoints - 5
			end
			obj.OnStart = function ()
				Objective_AddUIElements(obj, pos, true, BG_LocString(114), true)
			end
		end

		-- Set title
		obj.Title = BG_LocString(111)

	elseif objectiveType == BG_OT_DEFEND then

		obj.defendpos = pos
		obj.__oncheck = BattlegroundsDefence_CheckIsDefended
		obj.__oncomplete = function (self)
			DefenceSettingsData.DefenderPoints = DefenceSettingsData.DefenderPoints - 10
		end
		obj.__onstart = function(self)
			self.starttime = World_GetGameTime()
			self.endtime = World_GetGameTime() + 3 * 60
		end
		obj.OnStart = function ()
			Objective_StartTimer(obj, COUNT_DOWN, 3*60, 60);
		end
		obj.Title = BG_LocString(112)

	elseif objectiveType == BG_OT_SUPPORT then

		obj.defendpos = pos
		obj.__oncheck = BattlegroundsDefence_CheckIsSupported
		obj.__oncomplete = function (self)
			DefenceSettingsData.DefenderPoints = DefenceSettingsData.DefenderPoints - 5
		end
		obj.__onstart = function(self)
			self.starttime = World_GetGameTime()
			self.endtime = World_GetGameTime() + 3 * 60
		end
		obj.Title = BG_LocString(113)

	else
		fatal("Expected objective type value in interval 0 < type < 4 but got " .. tostring(objectiveType));
	end
	return obj
end

function BattlegroundsDefence_StartObjective(playerid, obj)

	-- Run triggers
	if obj.__onstart ~= nil then
		obj:__onstart() -- For global triggers
	end
	if obj.__onstartdefenders ~= nil then
		BattlegroundsDefence_TriggerDefender(obj, __onstartdefenders) -- Trigger to invoke enemy team (UI notifiers)
	end

	-- Start the objective visually on the local machine
	if Player_GetID(Game_GetLocalPlayer()) == playerid then
		Objective_Start(obj)
	end

end

function BattlegroundsDefence_CheckObjectives()

	-- Loop over all objectives and check them them
	for k,v in pairs(OBJ_DefenceAllAssault) do

		-- Make sure we have an objective
		if v.objectives[v.current] ~= nil then

			-- Check if complete
			if v.objectives[v.current]:__oncheck(k) then

				-- Trigger on complete
				v.objectives[v.current]:__oncomplete()

				-- Complete visually for local player
				if k == Player_GetID(Game_GetLocalPlayer()) then
					Objective_Complete(v.objectives[v.current], true);
				end

				-- Go to next
				v.current = v.current + 1

				-- Start it if defined
				if v.objectives[v.current] ~= nil then
					BattlegroundsDefence_StartObjective(k, v.objectives[v.current])
				end

			end

		end

	end

end

function BattlegroundsDefence_TriggerDefender(obj, func)
	for i=1, World_GetPlayerCount() do
		local p = World_GetPlayerAt(i)
		if Player_GetTeam(p) == bg_settings.team_second and p == Game_GetLocalPlayer() then
			func(obj)
		end
	end
end

function BattlegroundsDefence_CheckCapture(obj, playerid)

	-- Grab player and define how many have been captured
	local player = Player_FromId(playerid)
	local captured = 0

	-- Loop over points
	for _, v in pairs(obj.targets) do
		if Entity_IsStrategicPointCapturedBy(v, player) then
			captured = captured + 1
		end
	end

	-- Update visually
	if playerid == Player_GetID(Game_GetLocalPlayer()) then
		Objective_SetCounter(obj, captured, #obj.targets)
	end

	-- Return if we have captured the amount expected
	return captured == #obj.targets

end

function BattlegroundsDefence_CheckCleared(obj, playerid)
	
	-- Define sg and eg temps
	local sg_temp = SGroup_CreateIfNotFound("sg_temp_chckclear")
	local eg_temp = EGroup_CreateIfNotFound("eg_temp_chckclear");

	-- Grab team
	local attackers = Player_GetTeam(__BGDefenceTeams[1][1]);
	local defenders = Player_GetTeam(__BGDefenceTeams[2][1]);

	-- Grab units
	Team_GetAllEntitiesNearMarker(defenders, eg_temp, obj.attackpos, 30);
	Team_GetAllSquadsNearMarker(defenders, sg_temp, obj.attackpos, 30);

	-- Return if player can see position and has cleared all
	return Team_CanSee(attackers, obj.attackpos, ANY) and SGroup_Count(sg_temp) == 0 and EGroup_Count(eg_temp) == 0

end

function BattlegroundsDefence_CheckIsDefended(obj, playerid)
	-- TODO: Proper defence checks...
	return World_GetGameTime() > obj.endtime
end

function BattlegroundsDefence_CheckIsSupported(obj, playerid)
	-- TODO: More support checks
	return World_GetGameTime() > obj.endtime
end

------------------------------------------------------------------------------------
-- AI Stuff
------------------------------------------------------------------------------------
g_aidefenceunits = { -- just gonna use vanilla units for now, may change later
	["soviet"] = {
		infantry = "conscript_squad_mp",
		tank = "t_34_85_squad_mp"
	},
	["german"] = {
		infantry = "ostruppen_squad_mp",
		tank = "panzer_iv_squad_mp"
	},
	["west_german"] = {
		infantry = "volksgrenadier_squad_mp",
		tank = "panzer_iv_squad_mp"
	},
	["aef"] =  {
		infantry = "riflemen_squad_mp",
		tank = "m4a3_sherman_squad_mp"
	},
	["british"] = {
		infantry = "tommy_squad_mp",
		tank = "cromwell_mk4_75mm_squad_mp"
	}
}

function BattlegroundsDefence_InitAI()

	-- Invoke AI wave init if enabled (Defined in .json package)
	if bg_settings.gameoptions.Support then
		BattlegroundsDefence_InitAIWaves();
	end

end

function BattlegroundsDefence_InitAIWaves()

	-- Grab attacking team
	local attackers = __BGDefenceTeams[1];

	-- Init table
	__BGAISupport = {}
	for i, v in ipairs(attackers) do
		__BGAISupport[i] = {
			player = v,
			sgroup = SGroup_CreateIfNotFound("sg_bgaidef" .. tostring(i))
		};
	end

	-- Do interval
	Rule_AddInterval(BattlegroundsDefence_SpawnWave, 7);

end

-- Wave spawner
function BattlegroundsDefence_SpawnWave()

	-- Calculate how many units the AI can field for a player
	local maxcap = 5;
	if World_GetGameTime() > 15 * 60 then
		maxcap = 7;
	end

	-- Loop over players and spawn them in
	for _, v in pairs(__BGAISupport) do
		local target = BattlegroundsDefence_AIGetRandomTarget(v.player)
		if SGroup_Count(v.sgroup) < maxcap then

			-- Determine blueprint
			local bp = g_aidefenceunits[Player_GetRaceName(v.player)].infantry
			if World_GetRand(1,100) < 25 then
				bp = g_aidefenceunits[Player_GetRaceName(v.player)].tank
			end

			-- Spawn
			BattlegroundsDefence_SpawnAIUnit(v.player, v.sgroup, BP_GetSquadBlueprint(bp), target)

		end
		local foreach = function(gid, it, sid)
			if (not Squad_IsMoving(sid)) and (not Squad_IsUnderAttack(sid, 5)) then
				Cmd_AttackMove( v.sgroup, target, true, nil, 9.5);
			end
		end
		SGroup_ForEach(v.sgroup, foreach)
	end

end

function BattlegroundsDefence_AIGetRandomTarget(player)
	local available = {}
	for _, v in pairs(DefenceSettingsData.Sectors) do
		if not Entity_IsStrategicPointCapturedBy(v, player) then
			table.insert(available, v)
		end
	end
	if #available > 0 then
		return available[World_GetRand(1, #available)]
	else
		return Player_GetStartingPosition(Player_FindFirstEnemyPlayer(player))
	end
end

function BattlegroundsDefence_SpawnAIUnit(player, group, blueprint, target)

	-- Spawn
	local pos = Player_GetStartingPosition(player)
	local squad = Squad_CreateAndSpawnToward(blueprint, player, 0, pos, target)

	-- Make not selectable
	Misc_SetSquadSelectable(squad, false);

	-- Add to group and hide decorators
	SGroup_Add(group, squad)
	SGroup_EnableUIDecorator(group, false);

	-- Attack move (queue)
	Cmd_AttackMove( group, target, true, nil, 9.5);

end

------------------------------------------------------------------------------------
-- Hook
------------------------------------------------------------------------------------
bg_wchook = {
	init = {
		BattlegroundsDefence_InitGamemode,
		BattlegroundsDefence_InitDefence,
		BattlegroundsDefence_InitObjectives,
		BattlegroundsDefence_InitAI
	}
}
