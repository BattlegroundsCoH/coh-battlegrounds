------------------------------------------------------------
-- Math Set Functionality
------------------------------------------------------------
bg_set = {
    from_sgroup = function(self, sgroupTarget)
        local set = {};
        local __sgeach = function(sgroupid, itemindex, squadID)
            table.insert(set, Squad_GetGameID(squadID));
        end
        SGroup_ForEach(sgroupTarget, __sgeach);
        return set;
    end,
    union = function(self, a, b)
        local set = {};
        for i=1, #a do
            table.insert(set, a[i]);
        end
        for i=1, #b do
            if not self:contains(set, b[i]) then
                table.insert(set, b[i]);
            end
        end
        return set;
    end,
    intersect = function(self, a, b)
        local set = {};
        for i=1, #a do
            if self:contains(b, a[i]) then
                table.insert(set, a[i]);
            end
        end
        return set;
    end,
    diff = function(self, a, b)
        local set = {};
        for i=1, #a do
            if not self:contains(b, a[i]) then
                table.insert(set, a[i]);
            end
        end
        return set;
    end,
    contains = function(self, set, element)
        for i=1, #set do
            if (set[i] == element) then
                return true;
            end
        end
        return false;
    end,
};
------------------------------------------------------------
-- Vector (Position) Functionality
------------------------------------------------------------
function Vec3(_x, _y, _z)
    local vec = {
        x = _x,
        y = _y,
        z = _z,
        add = function(self, other)
            return Vec3(self.x + other.x, self.y + other.y, self.z + other.z);
        end,
        sub = function(self, other)
            return Vec3(other.x - self.x, other.y - self.y, other.z - self.z);
        end,
        mul = function(self, v)
        	return Vec3(self.x * v, self.y * v, self.z * v);
        end,
        negate = function(self)
            return Vec3(-self.x, -self.y, -self.z);
        end,
    	length = function(self)
    		return math.sqrt(self.x^2 + self.y^2 + self.z^2);
    	end,
    	unit = function(self)
    		local len = self:length();
    		return Vec3(self.x / len, self.y / len, self.z / len);
        end,
        toscar = function(self)
            return World_Pos(self.x, self.y, self.z);
        end,
    };
    return vec;
end

function Vec3Scar(pos)
    return Vec3(pos.x, pos.y, pos.z);
end
------------------------------------------------------------
-- SGroup functions
------------------------------------------------------------

function SGroup_FromSquad(squad, temp_name)
    if temp_name == nil then
        temp_name = "sg_temp";
    end
    sg_temp = SGroup_CreateIfNotFound(temp_name);
    SGroup_Clear(sg_temp);
    SGroup_Add(sg_temp, squad);
    return sg_temp;
end

__removewhennear = {}

function SGroup_MoveAndDespawn(squad, pos, callback)

    -- Tell the squad to stop first.
    Cmd_Stop(squad);

    -- Move to the position
    Cmd_Move(squad, pos);

    -- Add to near table
    table.insert(__removewhennear, { target = squad, location = pos, callbackfunc = callback });

    if not Rule_Exists(__SGREMOVE_WHEN_NEAR) then
        Rule_Add(__SGREMOVE_WHEN_NEAR);
    end

end

function __SGREMOVE_WHEN_NEAR()
    if #__removewhennear == 0 then
        Rule_RemoveMe();
    else
        for i=1, #__removewhennear do
            if SGroup_Count(__removewhennear[i].target) == 0 then
                table.remove(__removewhennear, i);
                break;
            else
                if Util_GetDistance(__removewhennear[i].location, SGroup_GetPosition(__removewhennear[i].target)) < 5 then
                    if __removewhennear[i].callbackfunc ~= nil then
                        __removewhennear[i].callbackfunc(__removewhennear[i].target);
                    end
                    SGroup_DeSpawn(__removewhennear[i].target);
                    table.remove(__removewhennear, i);
                    break;
                end
            end
        end
    end
end

------------------------------------------------------------
-- Squad functions
------------------------------------------------------------

function Squad_GetSyncWeapon(squad)
    for i=0, Squad_Count(squad) - 1 do
        local e = Squad_EntityAt(squad, i);
        if (Entity_IsSyncWeapon(e)) then
            return e;
        end
    end
    return nil;
end

------------------------------------------------------------
-- LocString functions
------------------------------------------------------------

function Util_CreateLocString(text)
	local tmpstr = LOC(text)
	tmpstr[1] = text
	return tmpstr
end

function BG_LocString(locID)
    return _bg_guid .. ":" .. tostring(locID);
end

function BG_LocStringFormat(locID, arg1, arg2, arg3, arg4)
    if arg2 == nil then
        return Loc_FormatText( _bg_guid .. ":" .. tostring(locID), arg1);
    elseif arg3 == nil then
        return Loc_FormatText( _bg_guid .. ":" .. tostring(locID), arg1, arg2);
    elseif arg4 == nil then
        return Loc_FormatText( _bg_guid .. ":" .. tostring(locID), arg1, arg2, arg3);
    else
        return Loc_FormatText( _bg_guid .. ":" .. tostring(locID), arg1, arg2, arg3, arg4);
    end
end

------------------------------------------------------------
-- Player functions
------------------------------------------------------------

___mapentrypoints = {}
function BG_UTIL_collect_map_entries()
    local bp_mapentry1 = BP_GetEntityBlueprint("map_entry_point");
    local bp_mapentry2 = BP_GetEntityBlueprint("map_entry_point_player");
    for i = 0, World_GetNumEntities() - 1 do
        local entity = World_GetEntity(i);
        local ebp = Entity_GetBlueprint(entity);
        if (ebp == bp_mapentry1 or ebp == bp_mapentry2) then
            table.insert(___mapentrypoints, { pos = Entity_GetPosition(entity), owner = Entity_GetPlayerOwner(entity) });
        end
    end
end

function Player_GetNearestMapEntry(player, refpoint)
    if (#___mapentrypoints == 0) then
        BG_UTIL_collect_map_entries();
    end
    local available = {};
    for i=1, #___mapentrypoints do
        if Player_GetRelationship(player, ___mapentrypoints[i].owner) ~= R_ENEMY then
            table.insert(available, ___mapentrypoints[i].pos);
        end
    end
    local j = 1;
    for i=1, #available do
        if (Util_GetDistance(refpoint, available[i] ) < Util_GetDistance(refpoint, available[j] )) then
            j = i;
        end
    end
    return available[j];
end

function Player_CallLocal(player, func)
    for i=1, World_GetPlayerCount() do
        if (World_GetPlayerAt(i) == player) then
            func(player);
        end
    end
end

function Player_ChangeResources(player, man, mun, ful)
    Player_AddResource(player, RT_Manpower, man);
    Player_AddResource(player, RT_Munition, mun);
    Player_AddResource(player, RT_Fuel, ful);
end

function Player_CanBuy(player, man, mun, ful)
    return Player_GetResource(player, RT_Manpower) >= man and Player_GetResource(player, RT_Munition) >= mun and Player_GetResource(player, RT_Fuel) >= ful;
end

------------------------------------------------------------
-- Team functions
------------------------------------------------------------

function Team_ForEachPlayer(team, func)
    for i=1, World_GetPlayerCount() do
        local p = World_GetPlayerAt(i);
        if (Player_GetTeam(p) == team) then
            func(p);
        end
    end
end

------------------------------------------------------------
-- String functions
------------------------------------------------------------
function Str_CmdParse(str)
    local t_result = {};
    for w in string.gmatch(str, "([%w-_]+)") do
        table.insert(t_result, w);
    end
    return t_result;
end

------------------------------------------------------------
-- Game functions
------------------------------------------------------------
function Game_SendMessage(msgType, msg)
    Command_PlayerBroadcastMessage(Game_GetLocalPlayer(), Game_GetLocalPlayer(), msgType, msg);
end

-- Dumps the type of the object. This is purely for debugging purposes
function Util_DumpObjectType(obj)
	if (obj == nil) then
		return;
	end
	local typeOfObject = scartype(obj);
	local resultOfOperation = "";
	if (typeOfObject == ST_UNKNOWN) then
		resultOfOperation = "Unkown";
	elseif (typeOfObject == ST_TABLE) then
		resultOfOperation = "Table (" .. #obj .. ")";
	elseif (typeOfObject == ST_STRING) then
		resultOfOperation = "String";
	elseif (typeOfObject == ST_SQUAD) then
		resultOfOperation = "Squad";
	elseif (typeOfObject == ST_SGROUP) then
		resultOfOperation = "SGroup";
	elseif (typeOfObject == ST_SCARPOS) then
		resultOfOperation = "Pos";
	elseif (typeOfObject == ST_PLAYER) then
		resultOfOperation = "Player";
	elseif (typeOfObject == ST_PBG) then
		resultOfOperation = "PBG (Blueprint)";
	elseif (typeOfObject == ST_MARKER) then
		resultOfOperation = "Marker";
	elseif (typeOfObject == ST_FUNCTION) then
		resultOfOperation = "Function";
	elseif (typeOfObject == ST_ENTITY) then
		resultOfOperation = "Entity";
	elseif (typeOfObject == ST_EGROUP) then
		resultOfOperation = "EGroup";
	elseif (typeOfObject == ST_CONSTPLAYER) then
		resultOfOperation = "ConstPlayer";
	elseif (typeOfObject == ST_BOOL) then
		resultOfOperation = "Bool";
	elseif (typeOfObject == ST_NUMBER) then
		resultOfOperation = "Number";
	end
	return resultOfOperation;
end

------------------------------------------------------------
-- Battlegrounds helper functions
------------------------------------------------------------
function Battlegrounds_FormatResources(cost, negate)
    local mp = cost.manpower or 0;
    local mu = cost.munitions or 0;
    local fu = cost.fuel or 0;
    if (negate) then
        mp = -mp;
        mu = -mp;
        fu = -fu;
    end
    return tostring(mp)..","..tostring(mu)..","..tostring(fu);
end


------------------------------------------------------------
-- Battlegrounds Tow System
------------------------------------------------------------
__BGTOWObjects = {};
__BGTOWIndexer = 0;

function Battlegrounds_TowFromOffmap(transportSquad, towTarget)

    local sg_tow_transport = SGroup_FromSquad(transportSquad, "sg_tow_transport_offmap" .. __BGTOWIndexer);
    local sg_tow_target = SGroup_FromSquad(towTarget, "sg_tow_target_offmap" .. __BGTOWIndexer);

    Modify_UnitSpeed( sg_tow_transport, 0.325);

    Cmd_InstantUpgrade( sg_tow_transport, BP_GetUpgradeBlueprint("142b113740474c82a60b0a428bd553d5:is_towing") );
    Cmd_InstantUpgrade( sg_tow_target, BP_GetUpgradeBlueprint("142b113740474c82a60b0a428bd553d5:is_towed") );

    Battlegrounds_TowAttach(transportSquad, towTarget);

end

function Battlegrounds_AETowAttach(executer, target)
    if scartype(target) == ST_ENTITY then
        Battlegrounds_TowAttach(executer, Entity_GetSquad(target));
    else
        Battlegrounds_TowAttach(executer, target);
    end
end

function Battlegrounds_TowAttach(executer, target)
    local tow_data = {
        tow_transport = executer,
        tow_transport_id = Squad_GetGameID(executer),
        tow_target = Squad_GetSyncWeapon(target),
        tow_target_id = Squad_GetGameID(target),
        tow_offset = -8.75,
    };
    local pos, dir = Battlegrounds_GetTowCoordinates(tow_data.tow_transport, tow_data.tow_offset);
    Entity_SetPosition(tow_data.tow_target, pos);
    Entity_SetHeading(tow_data.tow_target, dir, false);
    __BGTOWIndexer = __BGTOWIndexer + 1;
    table.insert(__BGTOWObjects, tow_data);
    if not Rule_Exists(__BgUpdateTOW) then
        Rule_Add(__BgUpdateTOW);
    end
end

function Battlegrounds_TowDetach(executer)
    for i=1, #__BGTOWObjects do
        if __BGTOWObjects[i].tow_transport == executer then
            table.remove(__BGTOWObjects, i);
            break;
        end
    end
end

function __BgUpdateTOW()
    if #__BGTOWObjects == 0 then
        Rule_RemoveMe();
    else
        for i=1, #__BGTOWObjects do
            local isTransportAlive = Squad_IsValid(__BGTOWObjects[i].tow_transport_id);
            local isTargetAlive = Squad_IsValid(__BGTOWObjects[i].tow_target_id);
            if isTargetAlive and isTargetAlive then
                local pos, dir = Battlegrounds_GetTowCoordinates(__BGTOWObjects[i].tow_transport, __BGTOWObjects[i].tow_offset);
                Entity_SetPosition(__BGTOWObjects[i].tow_target, pos);
                Entity_SetHeading(__BGTOWObjects[i].tow_target, dir, true);
            end
        end
    end
end

function Battlegrounds_GetTowCoordinates(transport, off)
    local tow_transport_pos = Vec3Scar(Squad_GetPosition(transport));
    local tow_transport_dir = Vec3Scar(Squad_GetHeading(transport)):unit();
    local tow_target_pos = tow_transport_dir:mul(off):add(tow_transport_pos);
    return tow_target_pos:toscar(), tow_transport_dir:negate():toscar();
end
