------------------------------------------------------------
-- Math Set Functionality
------------------------------------------------------------
bg_set = {
    from_sgroup = function(self, sgroupTarget)
        local set = {};
        local __sgeach = function(sgroupid, itemindex, squadID)
            table.insert(set, Squad_GetGameID(squadID));
        end
        SGroup_ForEach(sgroupTarget, __sgeach);
        return set;
    end,
    union = function(self, a, b)
        local set = {};
        for i=1, #a do
            table.insert(set, a[i]);
        end
        for i=1, #b do
            if not self:contains(set, b[i]) then
                table.insert(set, b[i]);
            end
        end
        return set;
    end,
    intersect = function(self, a, b)
        local set = {};
        for i=1, #a do
            if self:contains(b, a[i]) then
                table.insert(set, a[i]);
            end
        end
        return set;
    end,
    diff = function(self, a, b)
        local set = {};
        for i=1, #a do
            if not self:contains(b, a[i]) then
                table.insert(set, a[i]);
            end
        end
        return set;
    end,
    contains = function(self, set, element)
        for i=1, #set do
            if (set[i] == element) then
                return true;
            end
        end
        return false;
    end,
};

------------------------------------------------------------
-- SGroup functions
------------------------------------------------------------

function SGroup_FromSquad(squad, temp_name)
    if temp_name == nil then
        temp_name = "sg_temp";
    end
    sg_temp = SGroup_CreateIfNotFound(temp_name);
    SGroup_Clear(sg_temp);
    SGroup_Add(sg_temp, squad);
    return sg_temp;
end

__removewhennear = {}

function SGroup_MoveAndDespawn(squad, pos)

    -- Move to the position
    Cmd_Move(squad, pos);

    -- Add to near table
    table.insert(__removewhennear, { target = squad, location = pos });

    if not Rule_Exists(__SGREMOVE_WHEN_NEAR) then
        Rule_Add(__SGREMOVE_WHEN_NEAR);
    end

end

function __SGREMOVE_WHEN_NEAR()
    if #__removewhennear == 0 then
        Rule_RemoveMe();
    else
        for i=1, #__removewhennear do
            if SGroup_Count(__removewhennear[i].target) == 0 then
                table.remove(__removewhennear, i);
                break;
            else
                if Util_GetDistance(__removewhennear[i].location, SGroup_GetPosition(__removewhennear[i].target)) < 5 then
                    SGroup_DeSpawn(__removewhennear[i].target);
                    table.remove(__removewhennear, i);
                    break;
                end
            end
        end
    end
end

------------------------------------------------------------
-- LocString functions
------------------------------------------------------------

function Util_CreateLocString(text)
	local tmpstr = LOC(text)
	tmpstr[1] = text
	return tmpstr
end

------------------------------------------------------------
-- Player functions
------------------------------------------------------------

___mapentrypoints = {}
function BG_UTIL_collect_map_entries()
    local bp_mapentry1 = BP_GetEntityBlueprint("map_entry_point");
    local bp_mapentry2 = BP_GetEntityBlueprint("map_entry_point_player");
    for i = 0, World_GetNumEntities() - 1 do
        local entity = World_GetEntity(i);
        local ebp = Entity_GetBlueprint(entity);
        if (ebp == bp_mapentry1 or ebp == bp_mapentry2) then
            table.insert(___mapentrypoints, { pos = Entity_GetPosition(entity), owner = Entity_GetPlayerOwner(entity) });
        end
    end
end

function Player_GetNearestMapEntry(player, refpoint)
    if (#___mapentrypoints == 0) then
        BG_UTIL_collect_map_entries();
    end
    local available = {};
    for i=1, #___mapentrypoints do
        if Player_GetRelationship(player, ___mapentrypoints[i].owner) ~= R_ENEMY then
            table.insert(available, ___mapentrypoints[i].pos);
        end
    end
    local j = 1;
    for i=1, #available do
        if (Util_GetDistance(refpoint, available[i] ) < Util_GetDistance(refpoint, available[j] )) then
            j = i;
        end
    end
    return available[j];
end

function Player_CallLocal(player, func)
    for i=1, World_GetPlayerCount() do
        if (World_GetPlayerAt(i) == player) then
            func(player);
        end
    end
end

function Player_ChangeResources(player, man, mun, ful)
    Player_AddResource(player, RT_Manpower, man);
    Player_AddResource(player, RT_Munition, mun);
    Player_AddResource(player, RT_Fuel, ful);
end

------------------------------------------------------------
-- Team functions
------------------------------------------------------------

function Team_ForEachPlayer(team, func)
    for i=1, World_GetPlayerCount() do
        local p = World_GetPlayerAt(i);
        if (Player_GetTeam(p) == team) then
            func(p);
        end
    end
end

------------------------------------------------------------
-- String functions
------------------------------------------------------------
function Str_CmdParse(str)
    local t_result = {};
    for w in string.gmatch(str, "([%w-_]+)") do
        table.insert(t_result, w);
    end
    return t_result;
end

------------------------------------------------------------
-- Game functions
------------------------------------------------------------
function Game_SendMessage(msgType, msg)
    Command_PlayerBroadcastMessage(Game_GetLocalPlayer(), Game_GetLocalPlayer(), msgType, msg);
end

------------------------------------------------------------
-- Battlegrounds helper functions
------------------------------------------------------------
function Battlegrounds_FormatResources(cost, negate)
    local mp = cost.manpower or 0;
    local mu = cost.munitions or 0;
    local fu = cost.fuel or 0;
    if (negate) then
        mp = -mp;
        mu = -mp;
        fu = -fu;
    end
    return tostring(mp)..","..tostring(mu)..","..tostring(fu);
end
