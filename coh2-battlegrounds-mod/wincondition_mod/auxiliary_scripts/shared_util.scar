------------------------------------------------------------
-- Math Set Functionality
------------------------------------------------------------
bg_set = {
    from_sgroup = function(self, sgroupTarget)
        local set = {};
        local __sgeach = function(sgroupid, itemindex, squadID)
            table.insert(set, Squad_GetGameID(squadID));
        end
        SGroup_ForEach(sgroupTarget, __sgeach);
        return set;
    end,
    union = function(self, a, b)
        local set = {};
        for i=1, #a do
            table.insert(set, a[i]);
        end
        for i=1, #b do
            if not self:contains(set, b[i]) then
                table.insert(set, b[i]);
            end
        end
        return set;
    end,
    intersect = function(self, a, b)
        local set = {};
        for i=1, #a do
            if self:contains(b, a[i]) then
                table.insert(set, a[i]);
            end
        end
        return set;
    end,
    diff = function(self, a, b)
        local set = {};
        for i=1, #a do
            if not self:contains(b, a[i]) then
                table.insert(set, a[i]);
            end
        end
        return set;
    end,
    contains = function(self, set, element)
        for i=1, #set do
            if (set[i] == element) then
                return true;
            end
        end
        return false;
    end,
};

------------------------------------------------------------
-- SGroup functions
------------------------------------------------------------

function SGroup_FromSquad(squad)
    sg_temp = SGroup_CreateIfNotFound("sg_temp");
    SGroup_Clear(sg_temp);
    SGroup_Add(sg_temp, squad);
    return sg_temp;
end

------------------------------------------------------------
-- LocString functions
------------------------------------------------------------

function Util_CreateLocString(text)
	local tmpstr = LOC(text)
	tmpstr[1] = text
	return tmpstr
end

------------------------------------------------------------
-- Player functions
------------------------------------------------------------

___mapentrypoints = {}
function BG_UTIL_collect_map_entries()
    local bp_mapentry1 = BP_GetEntityBlueprint("map_entry_point");
    local bp_mapentry2 = BP_GetEntityBlueprint("map_entry_point_player");
    for i = 0, World_GetNumEntities() - 1 do
        local entity = World_GetEntity(i);
        local ebp = Entity_GetBlueprint(entity);
        if (ebp == bp_mapentry1 or ebp == bp_mapentry2) then
            table.insert(___mapentrypoints, { pos = Entity_GetPosition(entity), owner = Entity_GetPlayerOwner(entity) });
        end
    end
end

function Player_GetNearestMapEntry(player, refpoint)
    if (#___mapentrypoints == 0) then
        BG_UTIL_collect_map_entries();
    end
    local available = {};
    for i=1, #___mapentrypoints do
        if Player_GetRelationship(player, ___mapentrypoints[i].owner) ~= R_ENEMY then
            table.insert(available, ___mapentrypoints[i].pos);
        end
    end
    local j = 1;
    for i=1, #available do
        if (Util_GetDistance(refpoint, available[i] ) < Util_GetDistance(refpoint, available[j] )) then
            j = i;
        end
    end
    return available[j];
end

------------------------------------------------------------
-- Team functions
------------------------------------------------------------

function Team_ForEachPlayer(team, func)
    for i=1, World_GetPlayerCount() do
        local p = World_GetPlayerAt(i);
        if (Player_GetTeam(p) == team) then
            func(p);
        end
    end
end
